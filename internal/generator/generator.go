package generator

import (
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"github.com/nduyhai/mapgen/internal/model"
)

// Generator is responsible for generating code based on definitions.
type Generator interface {
	// Generate generates code based on a definition.
	Generate(def interface{}) error
}

// DefaultGenerator is the default implementation of Generator.
type DefaultGenerator struct {
	// SourceFile is the path to the source file.
	SourceFile string
}

// NewGenerator creates a new DefaultGenerator.
func NewGenerator(sourceFile string) *DefaultGenerator {
	return &DefaultGenerator{
		SourceFile: sourceFile,
	}
}

// Generate generates code based on a definition.
func (g *DefaultGenerator) Generate(def interface{}) error {
	switch d := def.(type) {
	case model.MapperDefinition:
		return g.generateMapper(d)
	default:
		return fmt.Errorf("unsupported definition type: %T", def)
	}
}

// generateMapper generates code for a mapper definition.
func (g *DefaultGenerator) generateMapper(def model.MapperDefinition) error {
	// Get the source directory
	sourceDir := filepath.Dir(g.SourceFile)

	// Determine the target file path
	var targetFile string

	// If target file is specified, use it
	if def.TargetFile != "" {
		// Use the target file as is, but in the source directory
		targetFile = filepath.Join(sourceDir, def.TargetFile)
	} else {
		// If target file is not specified, use the source file name with "_mapper" appended
		sourceFileName := filepath.Base(g.SourceFile)
		sourceFileExt := filepath.Ext(sourceFileName)
		sourceFileNameWithoutExt := strings.TrimSuffix(sourceFileName, sourceFileExt)

		// Append "_mapper" to the source file name
		targetFile = filepath.Join(sourceDir, sourceFileNameWithoutExt+"_mapper"+sourceFileExt)
	}

	// Parse the source file to extract import declarations
	fset := token.NewFileSet()
	sourceFile, err := parser.ParseFile(fset, g.SourceFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse source file %s: %w", g.SourceFile, err)
	}

	// Create a map of package names to import paths
	importMap := make(map[string]string)
	for _, imp := range sourceFile.Imports {
		// Extract the import path (removing quotes)
		importPath := strings.Trim(imp.Path.Value, "\"")

		// Extract the package name (last part of the import path)
		var packageName string
		if imp.Name != nil {
			// If the import has an alias, use it
			packageName = imp.Name.Name
		} else {
			// Otherwise, use the last part of the import path
			parts := strings.Split(importPath, "/")
			packageName = parts[len(parts)-1]
		}

		// Add to the map
		importMap[packageName] = importPath
	}

	// Update the imports in the definition with full paths
	updatedImports := make([]string, 0, len(def.Imports))
	for _, imp := range def.Imports {
		if fullPath, ok := importMap[imp]; ok {
			updatedImports = append(updatedImports, fullPath)
		} else {
			// If we can't find the full path, use the original import
			updatedImports = append(updatedImports, imp)
		}
	}
	def.Imports = updatedImports

	// Generate the code
	code := g.generateMapperCode(def)

	// Write the code to the target file
	err = os.WriteFile(targetFile, []byte(code), 0644)
	if err != nil {
		return fmt.Errorf("failed to write to file %s: %w", targetFile, err)
	}

	fmt.Printf("Generated mapper code in %s\n", targetFile)
	return nil
}

// generateMapperCode generates the code for a mapper.
func (g *DefaultGenerator) generateMapperCode(def model.MapperDefinition) string {
	// Generate the code header
	code := fmt.Sprintf("// Code generated by mapgen; DO NOT EDIT.\n\n")
	code += fmt.Sprintf("package %s\n\n", def.Package)

	// Add import statements if there are any imports
	if len(def.Imports) > 0 {
		code += "import (\n"
		for _, imp := range def.Imports {
			code += fmt.Sprintf("\t\"%s\"\n", imp)
		}
		code += ")\n\n"
	}

	code += fmt.Sprintf("// %s is a generated mapper implementation.\n", def.ImplName)
	code += fmt.Sprintf("type %s struct{}\n\n", def.ImplName)

	// Generate code for each method
	for _, method := range def.Methods {
		code += fmt.Sprintf("// %s maps from %s to %s.\n", method.Name, method.SourceType, method.TargetType)
		code += fmt.Sprintf("func (m *%s) %s(source %s) %s {\n", def.ImplName, method.Name, method.SourceType, method.TargetType)

		// Create a new target object
		targetType := strings.TrimPrefix(method.TargetType, "*")
		code += fmt.Sprintf("\ttarget := &%s{}\n", targetType)

		// If there are mappings, use them to implement the mapping logic
		if len(method.Mappings) > 0 {
			code += fmt.Sprintf("\n\t// Apply field mappings\n")

			for _, mapping := range method.Mappings {
				if mapping.Ignore {
					// Skip ignored fields
					code += fmt.Sprintf("\t// Ignoring field: %s\n", mapping.From)
					continue
				}

				// Map the field
				if mapping.Using != "" {
					// Use a custom mapping function
					if mapping.From != "" {
						// If From is specified, pass it to the function
						code += fmt.Sprintf("\ttarget.%s = %s(source.%s)\n", mapping.To, mapping.Using, mapping.From)
					} else {
						// If From is not specified, call the function without parameters
						code += fmt.Sprintf("\ttarget.%s = %s()\n", mapping.To, mapping.Using)
					}
				} else {
					// Direct mapping
					code += fmt.Sprintf("\ttarget.%s = source.%s\n", mapping.To, mapping.From)
				}
			}
		} else {
			// No mappings, use a default implementation
			code += fmt.Sprintf("\t// TODO: Implement mapping logic\n")
		}

		// Return the target object
		code += fmt.Sprintf("\n\treturn target\n")
		code += fmt.Sprintf("}\n\n")
	}

	return code
}
